[{"body":"Required install ScopeFoundry\nAfter installation, use anaconda prompt and navigate to where you want or have the source code for your setup and start ScopeFoundry.tools:\n$ cd \"to/your_project_folder\" $ conda activate scopefoundry $ python -m ScopeFoundry.tools Go to the new app and press new app. This copied the scope foundry example files to your project folder. In your anaconda(3) prompt run:\n$ python example_slowscan_app.py you should see:\nFolder structure and take home messages Now is a good time to learn the bare minimum of ScopeFoundry. On the left panel you see a 2 lists.\nHardware: are made of HardwareComponent who job it is to establish a connection to your hardware, readout and set values.\nMeasurements: are made of Measurement classes that define the procedures of aquiring and saving data. They can have graphical user interfaces shown on the right. Can you start the example_2d_scan?\nNote that you can expand the the item in either list to expose settings that can be linked to the state of the hardware and parameterize you measurements respectively.\nThe folder structure should be of this form:\n├── your_project_folder ├── ScopeFoundryHW ├── company1_model1 ├── company1_model1_hw.py\t├── company1_model1_dev.py\t├── company1_model1_test_app.py ├── Licence ├── README.md ** ** ├── fancy_app.py ├── your_measurement_1.py ├── ** # after databrowser tutorial ├── viewers.py ├── images.py ├── fancy_data_browser.py In particular the folder contains:\nA subfolder ScopeFoundryHW containing hardware control code. There must be at least a file, typically ending with _hw.py, that contains a subclass of type HardwareComponent. measurement files containing Measurement subclasses. The actual app file where Measurement und HardwareComponent are added to the main app. That is the file that gets run. Congratulations, you have created your first microscope and saw the 3 most prutent high level concepts. HardwareComponent and Measurement can each have settings.\nNext Steps Now that you have interacted with ScopeFoundry and built a microscope app with pre-built components, you probably would like to build a system that allows you to do real scientific experiements. To do this have a look at tutorials on how to build\na custom Hardware Component a custom Measurement ","categories":"","description":"Learn how to setup ScopeFoundry and create your first Microscope App","excerpt":"Learn how to setup ScopeFoundry and create your first Microscope App","ref":"/docs/10_tutorials/1_new-microscope-app/","tags":"","title":"New microscope app"},{"body":"Step 1: Installing Python and ScopeFoundry Note: We recommend the Anaconda Python distribution, which contains many easy-to-install scientific python packages.\nDownload and Install Anaconda. The recommended Python version is 3.11, but 2.7 may also work (but is currently untested). If you already had a non-Anaconda version of python installed, you will need to make sure you use Anaconda if you would like to follow the instructions below.\nAnaconda provides a way to make a clean set of packages in an “environment”. Follow these steps to create an conda environment. This environment includes ScopeFoundry and all of the packages ScopeFoundry needs to run.\nWindows\nOpen an Anaconda prompt and run the following commands:\n\u003e conda create -n scopefoundry python=3.12 \u003e conda activate scopefoundry (scopefoundry) \u003e conda install numpy pyqt qtpy h5py pyqtgraph pyserial matplotlib qtconsole (scopefoundry) \u003e pip install ScopeFoundry The first two lines create and activate a clean python / conda environment for your ScopeFoundry app to use, the next lines install the required packages and the final line install the ScopeFoundry package itself.\nThe use of the conda environment is optional, but provides a clean, known working environment for ScopeFoundry\nMac / Linux\nOpen a terminal and run the following commands:\n$ conda create -n scopefoundry python=3.11 $ source activate scopefoundry (scopefoundry) $ conda install numpy pyqt qtpy h5py pyqtgraph (scopefoundry) $ pip install ScopeFoundry The first two lines create and activate a clean python / conda environment for your ScopeFoundry app to use, the next lines install the required packages and the final line install the ScopeFoundry package itself.\nStep 2: Create your Microscope App Make a new directory/folder for you microscope, say fancy_microscope, and create a file inside called fancy_microscope.py (a complete version of this file is available here). Copy and paste the following content into this file and save it.\nThis file tells ScopeFoundry all about your microscope – like any hardware and measurement components that are part of your microscope setup.\nScopeFoundry assumes a few basic things about your microscope, but not many. The basic assumptions it makes are part of BaseMicroscopeApp python class, which we import here.\nWhen you define your microscope app, FancyMicroscopeApp, it inherits from its parent class, BaseMicroscopeApp. You then you add your own bells and whistles in your setup() method. The code below has comments about what we can do during setup, but so far is left blank.\nIf you run this file as a python script, the last few lines tell python to create an instance of FancyMicroscopeApp and then run it.\nfrom ScopeFoundry import BaseMicroscopeApp class FancyMicroscopeApp(BaseMicroscopeApp): # this is the name of the microscope that ScopeFoundry uses # when storing data name = 'fancy_microscope' # You must define a setup function that adds all the #capablities of the microscope and sets default settings def setup(self): #Add App wide settings #Add hardware components print(\"Adding Hardware Components\") #Add measurement components print(\"Create Measurement objects\") # Connect to custom gui # load side panel UI # show ui self.ui.show() self.ui.activateWindow() if __name__ == '__main__': import sys app = FancyMicroscopeApp(sys.argv) sys.exit(app.exec_()) Let’s test our empty microscope app:\nin your terminal window: python fancy_microscope_app.py and you will be greeted something like this:\nIn the next step we’ll tell you how to add some pre-built bells and whistles to make this more useful. (Yes, we know, you want custom ones. We’ll teach you how to do that, too!)\nStep 3: Install hardware and measurement components Now, we will learn how to add piece of hardware to your microscope. We have a virtual function generator that acts like an analog input attached to a function generator that makes sine and square waves. Let’s install this package which is available on the ScopeFoundry GitHub project:\n(scopefoundry) $ pip install git+https://github.com/ScopeFoundry/HW_virtual_function_gen.git Now python has access to the functions and modules provided by this package.\nHardware Component Add the hardware component to your microscope app by adding these lines to your app’s setup() function:\ndef setup(self): ... #Add Hardware components from ScopeFoundryHW.virtual_function_gen.vfunc_gen_hw import VirtualFunctionGenHW self.add_hardware(VirtualFunctionGenHW(self)) ... We need two lines in the setup function to use this hardware component. The first line tells python where to find the hardware component, via an import statement. The next line creates an instance of the hardware (an active copy in memory), and then adds it to your App.\nNotice that ScopeFoundry Hardware components always have the suffix “HW”.\nMeasurement Component The virtual_function_gen package also provides a way to capture the data, display and save the data from the our new hardware component. This is encapuslated in a ScopeFoundry Measurement class. Let’s include a sine_wave_plot measurement in our App by adding a couple lines to our setup() function:\ndef setup(self): ... #Add Measurement components from ScopeFoundryHW.virtual_function_gen.sine_wave_measure import SineWavePlotMeasure self.add_measurement(SineWavePlotMeasure(self)) ... Notice that ScopeFoundry Measurement class names always have the suffix “Measure”.\nStep 4: Run your App Now that we have the basics of our app. We can open it, run our measurement and save some data.\nAgain, in your terminal window: python fancy_microscope_app.py and you will be greeted something like this:\nIn this graphical interface we do the following:\nConnect to hardware (here our virtual_function_gen hardware component)\nExpand the virtual_function_gen section of the Hardware tree Click the connected checkbox Configure the Hardware:\nIn the virtual_function_gen section of the Hardware tree, set the amplitude Choose Data save directory and sample meta data\nIn the App box or File menu, choose your data save directory. The default is the data/ folder inside the App directory. Sample name can be set in the App box in bottom left. Setup measurement conditions (How often we sample the data, if we are saving a data file)\nExpand the sine_wave_plot section of the Measurements tree adjust the sampling_period setting Run the measurement:\nTo start the measurement we can check the activation checkbox, or click on the start button. Observe data flowing in! The plot on the right panel will update as data is acquired. Stop the measurement via the interrupt button or unchecking activation Step 5: Analyze Data The measurement will auto-save a data-file that contains the optimizer history to an HDF5 (.h5) data file within the specified Save Directory. This data file contains the data along with data structures that include all the meta-data from the microscope App. To view this data file, we can use a graphical viewer HDFView, or use the FoundryDataBrowser from the ScopeFoundry project.\nThe data file created by the sine_wave_plot measurement has the following hierarchy:\n|\u003e app |- name = vfunc_gen_test_app |- ScopeFoundry_type = App |\u003e settings |- save_dir = ~/fancy_microscope/data |- sample = Test Sample 42 |\u003e units |\u003e hardware |- ScopeFoundry_type = HardwareList |\u003e virtual_function_gen |- name = virtual_function_gen |- ScopeFoundry_type = Hardware |\u003e settings |- connected = True |- debug_mode = False |- amplitude = 1.0 |- rand_data = 0.5191185618096453 |- sine_data = 0.9099735972719286 |- square_data = -1.0 |\u003e units |\u003e measurement |\u003e sine_wave_plot |- name = sine_wave_plot |- ScopeFoundry_type = Measurement |D buffer: (120,) float64 |\u003e settings |- activation = False |- running = True |- progress = 50.0 |- save_h5 = True |- sampling_period = 0.1 |\u003e units |- progress = % |- sampling_period = s You will notice that this data file contains much more than just the sine wave data recorded during your measurement. It also contains all the settings of the hardware and measurement conditions at the time of the data acquisition.\nWe can access this data file in Python using the h5py package.\nimport h5py dat = h5py.File('1486144636_sine_wave_plot.h5', 'r') sample_name = dat['app/settings'].attrs['sample'] print(sample_name) # Test Sample 42 buffer_data = dat['measurement/sine_wave_plot/buffer'] import matplotlib.pyplot as plt plt.title(sample_name) plt.plot( buffer_data) plt.savefig('sine_wave_data_plot_42.png') plt.show() Next Steps Now that you have interacted with ScopeFoundry and built a microscope app with pre-built components, you probably would like to build a system that allows you to do real scientific experiements. To do this we need to build custom measurement types and potentially new hardware components for ScopeFoundry.\nSee these tutorials for a more detailed look into how to customize your microscope with ScopeFoundry:\nScopeFoundry Key Concepts Build a custom Measurement Build a custom Hardware Component Build a custom Data Browser View for your data files Create a custom side bar Where to Find Out More This tutorial code is here: fancy_microscope_app.py\nThe package that includes the hardware and measurement components used in this tutorial are available in this code repository: virtual_function_gen.\nFor questions about this tutorial or ScopeFoundry in general, please visit and post on the ScopeFoundry project mailing list and forum.\nFor source code of all ScopeFoundry projects visit our GitHub page.\n","categories":"","description":"Learn how to setup ScopeFoundry and create your first Microscope App","excerpt":"Learn how to setup ScopeFoundry and create your first Microscope App","ref":"/docs/tutorials/first-microscope-app/","tags":"","title":"Building Your First Microscope App"},{"body":" ScopeFoundry is an open-source alternative to LabView or MATLAB instrument control software.\nFree \u0026 Open Source Instrument Control Software ScopeFoundry is an open-source alternative to LabView or MATLAB instrument control software.\nFeatures:\nModular, cross-platform Python graphical interface allows for fast data acquisition and visualization Build lab equipment graphical interfaces interactively with Qt Creator Live updates of measurement code for fast development and debugging Hardware plug-ins for simple and complex scientific equipment Uses\nCurrently used in multi-modal scanning microscopy measurements with electrons and optics Flexible for many other data acquisition tasks Where should I go next? Give your users next steps from the Overview. For example:\nGetting Started: Get started with ScopeFoundry Tutorial ","categories":"","description":"A Python platform for controlling custom laboratory experiments and visualizing scientific data.","excerpt":"A Python platform for controlling custom laboratory experiments and …","ref":"/docs/overview/","tags":"","title":"About"},{"body":"Requirements: install scope_foundry\nTo create the app and add viewer that ship with ScopeFoundry create this file:\n# fancy_data_browser.py import sys from ScopeFoundry.data_browser import DataBrowser from ScopeFoundry.data_browser.plug_ins.h5_search import H5SearchPlugIn from ScopeFoundry.data_browser.plug_ins.time_note import TimeNote from ScopeFoundry.data_browser.viewers import H5TreeView, RangedOptimizationH5View from ScopeFoundry.helper_funcs import sibling_path # LOGO_PATH = \"your_logo.png\" class MyDataBrowser(DataBrowser): def setup(self): self.add_plugin(H5SearchPlugIn(self)) self.add_plugin(TimeNote(self)) self.add_view(H5TreeView(self)) self.add_view(RangedOptimizationH5View(self)) if __name__ == \"__main__\": app = MyDataBrowser(sys.argv) # app.set_logo(LOGO_PATH) # app.settings_load_ini(\"defaults.ini\") sys.exit(app.exec_()) resulting in:\nnext learn to create a Viewer\n","categories":"","description":"Learn how to create custom DataBrowserApp","excerpt":"Learn how to create custom DataBrowserApp","ref":"/docs/12_databrowser-tutorials/1_data-browser-app/","tags":"","title":"DataBrowserApp"},{"body":"Note: We recommend the Anaconda Python distribution, which contains many easy-to-install scientific python packages. If you already had a non-Anaconda version of python installed, you will need to make sure you use Anaconda in order to follow the instructions below.\nDownload and Install Anaconda. The current recommended Python version is 3.11. Other Python 3 versions should work but are not actively tested.\nAnaconda provides a way to make a clean set of packages in an “environment”. Follow these steps to create an conda environment. This environment includes ScopeFoundry and all of the packages ScopeFoundry needs to run.\nWindows\nOpen an Anaconda prompt and run the following commands:\n\u003e conda create -n scopefoundry python=3.11 \u003e conda activate scopefoundry (scopefoundry) \u003e conda install numpy pyqt qtpy h5py pyqtgraph pyserial matplotlib qtconsole (scopefoundry) \u003e pip install ScopeFoundry The first two lines create and activate a clean python / conda environment for your ScopeFoundry app to use, the next lines install the required packages and the final line install the ScopeFoundry package itself.\nThe use of the conda environment is optional, but provides a clean, known working environment for ScopeFoundry\nMac / Linux\nOpen a terminal and run the following commands:\n$ conda create -n scopefoundry python=3.11 $ conda activate scopefoundry (scopefoundry) $ conda install numpy pyqt qtpy h5py pyqtgraph (scopefoundry) $ pip install ScopeFoundry The first two lines create and activate a clean python / conda environment for your ScopeFoundry app to use, the next lines install the required packages and the final line install the ScopeFoundry package itself.\n","categories":"","description":"Installing ScopeFoundry and its dependencies.","excerpt":"Installing ScopeFoundry and its dependencies.","ref":"/docs/getting-started/","tags":"","title":"Getting Started"},{"body":"Here we discuss how to build a custom hardware plug-in for ScopeFoundry. If one is not available in our list of plug-ins, you can build one based on the tutorial. By the end of part 1, you have created a plugin that is a virtual sine wave generator and you will have learned basic ScopeFoundry concepts. Virtual because we just simulate values that in practice will come from a physical device. In part 2 we will close the gap.\nFirst steps To get started, in your anaconda prompt or terminal cd to your folder and run the ScopeFoundry.tools:\n$ cd \"to/your_project_folder\" $ conda activate scopefoundry $ python -m ScopeFoundry.tools Fill out the new hardware tab as below and hit create new hardware:\nNote, that this generated the required files in your ScopeFoundryHW folder. You can copy the content of import statements into your fancy_app.py file (that you already have generated in a prev tutorial renamed from example_2d_slow_scan_app.py to fancy_app.py). If you used the values entered above your fancy_app.py should look like:\n# fancy_app.py import sys from ScopeFoundry import BaseMicroscopeApp class FancyApp(BaseMicroscopeApp): name = \"fancy app\" def setup(self): from ScopeFoundryHW.random_number_gen import (NumberGenHw, NumberGenReadout) self.add_hardware(NumberGenHw(self)) self.add_measurement(NumberGenReadout(self)) if __name__ == \"__main__\": app = FancyApp(sys.argv) # app.settings_load_ini(\"default_se ttings.ini\") sys.exit(app.exec_()) From here, in general, 2 files in ScopeFoundryHW/random_number_gen are important and will be modified to complete part 1:\nLow level interface: number_gen_dev.py In general, this file functions as a low-level interface between ScopeFoundry and a process or demon running on the operating system that communicates with the hardware. For now, this file will be just given and simulates values for a sine wave function generator. In part 2 we give some tips on how to write this in practice.\nGo ahead and replace the content of random_gen_dev.dev with the following content\n# number_gen_dev.py import time import numpy as np class NumberGenDev: \"\"\" This is the low level dummy device object. Typically when instantiated it will connect to the real-world Methods allow for device read and write functions \"\"\" def __init__(self, port=None, debug=False): \"\"\"We would connect to the real-world here if this were a real device \"\"\" self.port = port self.debug = debug print(\"NumberGenDev: Connecting to port\", port) self.write_amp(1) def write_amp(self, amplitude): \"\"\" A write function to change the device's amplitude normally this would talk to the real-world to change a setting on the device \"\"\" self._amplitude = amplitude def read_rand_num(self): \"\"\" Read function to access a Random number generator. Acts as our scientific device picking up a lot of noise. \"\"\" rand_data = np.random.ranf() * self._amplitude return rand_data def read_sine_wave(self): \"\"\" Read function to access a sine wave. Acts like the device is generating a 1Hz sine wave with an amplitude set by write_amp \"\"\" sine_data = np.sin(time.time()) * self._amplitude return sine_data if __name__ == '__main__': print('start') dev = NumberGenDev(port=\"COM1\", debug=True) print(dev.read_sine_wave()) print('done') Some comments: When we create an instance of this device class, we begin communication with the device. Other methods with names starting with read_ or write_ are the messages we can pass back and forth to the device.\nIn this case, we defined a method read_rand_num which uses a random number generator from numpy and returns a random value every time it’s called. This function is referenced in the hardware plugin section below code.\nIn the case where you would like to connect to real scientific equipment and define basic functions based on its communication protocol, I would recommend the following:\nDefine whichever addresses and ports you would like to use using variables defined in the module’s __init__() method. Then define a write function which can send messages to the device over RS232, Ethernet, via DLL or other protocol as required. The actual ScopeFoundry Hardware plug-in The next step is to create a subclass ScopeFoundry.hardware.HardwareComponent that will be added to the app.\nThe required methods are: setup(), connect(), and disconnect().\n# number_gen_hw.py from ScopeFoundry.hardware import HardwareComponent class NumberGenHw(HardwareComponent): name = \"number_gen\" def setup(self): s = self.settings s.New(\"port\", str, initial=\"COM1\", description=\"has no effect for this dummy device\") s.New(\"amplitude\", float, initial=1.0, ro=False) s.New(\"rand_data\", float, initial=0, ro=True) s.New(\"sine_data\", float, initial=0, ro=True) def connect(self): from .number_gen_dev import NumberGenDev s = self.settings self.dev = NumberGenDev(s[\"port\"], debug=s[\"debug_mode\"]) # Connect settings to hardware: s.get_lq(\"amplitude\").connect_to_hardware(write_func=self.dev.write_amp) s.get_lq(\"rand_data\").connect_to_hardware(read_func=self.dev.read_rand_num) s.get_lq(\"sine_data\").connect_to_hardware(read_func=self.dev.read_sine_wave) # Take an initial sample of the data. self.read_from_hardware() def disconnect(self): if not hasattr(self, \"dev\"): return self.settings.disconnect_all_from_hardware() del self.dev # if you want to continuously update settings implement *run* method # def run(self): # self.settings.property_x.read_from_hardware() # time.sleep(0.1) There are several critical components contained within this module which essentially handle signals, settings, and links to low-level device functions.\nFor the sake of simplicity, we’ve omitted hardware level signals in this basic tutorial.\nclass: We make our module a subclass of HardwareComponent. setup()\nHere we set up a few settings for this hardware, these settings are LoggedQuantity objects that contain a hardware value that can be read or written. This object helps keep this value in sync between hardware, measurement and graphical interface. connect()\nWe define an object self.dev which instantiates the low-level device wrapper and thereby accesses hardware functions. Using connect_to_hardware() we link to the device level self.dev.rand_func. Every time we call settings.get_lq(\"rand_data\").read_from_hardware(), the linked functions will be called. We run self.read_from_hardware() to update all hardware-connected settings with initial readout values. disconnect()\nWe clean up the mess we made by removing objects after use. By having the connect() and disconnect() we can cleanly reconnect hardware during an App run. This is especially useful when debugging a hardware plug-in to a new device.\nThe final result Test by running:\n$ python fancy_app.py You should see:\nNote that we have implicitly created and added a measurement to the app. It is not working yet, this will be part of the next tutorial.\n","categories":"","description":"getting started and learning ScopeFoundry.hardware concepts","excerpt":"getting started and learning ScopeFoundry.hardware concepts","ref":"/docs/10_tutorials/2_hardware-1/","tags":"","title":"Hardware 1 - Getting started"},{"body":"We will be describing how to build the sine_wave_plot measurement that is part of the virtual_function_gen ScopeFoundryHW package.\nBasic Structure A ScopeFoundry Measurement is defined as a sub-class of ScopeFoundry.Measurement with a few methods (functions) defined that will describe how to setup up the measurement’s data structures (setup()) and user interface (setup_figure()) as well as functions to define the Measurement procedure (run()) and display (update_display()). We will expand on each of these functions in the next few sections.\nfrom ScopeFoundry import Measurement # Our measurement inherits from the ScopeFoundry Measurement class class SineWavePlotMeasure(Measurement): # this is the name of the measurement that ScopeFoundry uses # when displaying your measurement and saving data related to it name = \"sine_wave_plot\" def setup(self): \"\"\" Runs once during App initialization. This is the place to load a user interface file, define settings, and set up data structures. \"\"\" def setup_figure(self): \"\"\" Runs once during App initialization, after setup() This is the place to make all graphical interface initializations, build plots, etc. \"\"\" def run(self): \"\"\" Runs when measurement is started. Runs in a separate thread from GUI. It should not update the graphical interface directly, and should only focus on data acquisition. \"\"\" def update_display(self): \"\"\" Displays (plots) the data This function runs repeatedly and automatically during the measurement run. its update frequency is defined by self.display_update_period \"\"\" We add this Measurement to our MicroscopeApp by the app’s add_measurement() method:\nclass FancyMicroscopeApp(BaseMicroscopeApp): ... def setup(self): ... #Add Measurement components from ScopeFoundryHW.virtual_function_gen import SineWavePlotMeasure self.add_measurement(SineWavePlotMeasure(self)) ... Measurement Settings setup()\nRun() run()\nDefine measurement steps Saving data to disk Interrupting a measurement Build a user interface Load ui in setup() loading to setup()\nBringing user interface to life setup_figure() and update_display()\nConnect graphical widgets to code def setup_figure(self): ... # connect ui widgets to measurement/hardware settings or functions self.ui.start_pushButton.clicked.connect(self.start) self.ui.interrupt_pushButton.clicked.connect(self.interrupt) self.settings.save_h5.connect_to_widget(self.ui.save_h5_checkBox) self.func_gen.settings.amplitude.connect_to_widget(self.ui.amp_doubleSpinBox) ... Create PyQtGraph plots def setup_figure(self): ... # Set up pyqtgraph graph_layout in the UI self.graph_layout=pg.GraphicsLayoutWidget() self.ui.plot_groupBox.layout().addWidget(self.graph_layout) # Create PlotItem object (a set of axes) self.plot = self.graph_layout.addPlot(title=\"Sine Wave Readout Plot\") # Create PlotDataItem object ( a scatter plot on the axes ) self.optimize_plot_line = self.plot.plot([0]) ... Update plots during run() In order to see the data as it is aquired, an update_display() function is called repeatedly at an interval defined by self.display_update_period (in seconds). This value is set by default to 0.1 seconds, but can be updated in setup_figure().\nSince we created all the plot objects during setup_figure() this update_display() function can be quite simple. Here we update the optimze_plot_line using the data in self.buffer, which is being filled by the Measurement run() thread.\ndef update_display(self): self.optimize_plot_line.setData(self.buffer) Interacting with Measurement ","categories":"","description":"Learn how to build a custom Measurement component for ScopeFoundry.","excerpt":"Learn how to build a custom Measurement component for ScopeFoundry.","ref":"/docs/tutorials/custom-measurements/","tags":"","title":"Create a Custom Measurement Component"},{"body":"The goals of this tutorial is to\nHelp you build your first microscope app Provide some documentation Use ScopeFoundry.tools efficiently Acces code from tutorial repository\nIf you are new, we recommend you to take all basic tutorials in order\n","categories":"","description":"Learn to write your own custom ScopeFoundry hardware and measurement plugins.","excerpt":"Learn to write your own custom ScopeFoundry hardware and measurement …","ref":"/docs/10_tutorials/","tags":"","title":"Basic Tutorials"},{"body":"Development Environment Python via Anaconda To have a consistent python environment for using and developing ScopeFoundry, we recommend the Anaconda python distribution and using conda environments to manage packages.\nDownload and Install Anaconda. Recommended Python version is 3.7. Other versions of Python 3 are not actively tested at this time, but should generally work.\nCreate an conda environment includes ScopeFoundry and its dependencies. Open an Anaconda prompt and run the following commands:\n$ conda create -n scopefoundry python=3.7 anaconda $ conda activate scopefoundry (scopefoundry) $ conda install pyqtgraph If you would like a more minimal environment, without all the default packages from Anaconda:\n$ conda create -n scopefoundry python=3.7 $ source activate scopefoundry (scopefoundry) $ conda install numpy pyqt qtpy h5py (scopefoundry) $ pip install pyqtgraph ScopeFoundry is available to download from PyPI or install via pip install ScopeFoundry.\nHowever, if you are interested in using the latest development version of ScopeFoundry, instead of the most recent release on PyPI, you can install via git. To install the latest development version of ScopeFoundry from github:\n(scopefoundry) $ pip install git+git://github.com/ScopeFoundry/ScopeFoundry.git Eclipse + PyDev IDE For an IDE we recommend Eclipse with the PyDev plugin. While the setup is more complicated than many other IDE’s, there is one very useful feature available in PyDev that not available elsewhere: Live code reloading. This allows a developer to modify any function in ScopeFoundry from within Eclipse and have that new version of the function injected into the running ScopeFoundry App.\nTo install, download Eclipse Installer. Install Eclipse for Java developers Open Eclipse, go to Eclipse Marketplace... menu item Search for “PyDev” and install Configure your PyDev python interpreter. Make sure to point it at your scopefoundry conda environment. Run your App script in Eclipse’s Debug Mode to enable live code reloading Keep track of history It is a good idea to use a version-control system (VCS) to keep track of the code that runs your experiment. This allows you to have a record of the software used to acquire data on a specific day of experiments. It also protects against accidental and untraceable changes to code on your microscope that could affect how data is acquired. The current recommended VCS for ScopeFoundry projects is Git.\nLets create a git repository to store the code for the microscope app\nmkdir fancy_microscope cd fancy_microscope git init We add files using:\ngit add fancy_microscope_app.py And commit changes to perminanet history using\ngit commit -m \"cool changes happen here\"\nThere are are many tutorials on web that address how to use git effectively, so we will not repeat that here.\nThere are also good graphical interfaces to Git that you may want to check out. One recommendation SourceTree which is available for no cost.\nGit subtree to modify plugins If we want to modify existing hardware or measurements plug-ins we can use git subtree to import plugins into a git repository, track local changes to the plugin , and finally push these plug-in changes upstream.\nIf we have a microscope repository fancy_microscope that we would like to modify the code for ascom_camera we can at it locally to our microscope with:\ncd fancy_microscope git subtree add --prefix ScopeFoundryHW/ascom_camera/ \\ https://github.com/ScopeFoundry/HW_ascom_camera.git master After modification of the plugin we can push the changes in the plugin subdirectory.\ngit subtree push --prefix ScopeFoundryHW/ascom_camera/ \\ https://user@github.com/ScopeFoundry/HW_ascom_camera.git master You will need commit access to do this, but you can always fork the plug-in repo, and submit pull-requests via the ScopeFoundry GitHub page.\nLocal copy of ScopeFoundry If you would like to have a local copy of ScopeFoundry to modify within your microscope repository, you can use git-subtree to make a local copy:\ngit subtree add --prefixScopeFoundry https://github.com/ScopeFoundry/ScopeFoundry.git master Where to Find Out More For questions about this documentation or ScopeFoundry in general, please visit and post on the ScopeFoundry project mailing list and forum.\nFor source code of all ScopeFoundry projects visit our GitHub page.\nScopeFoundry is available to download from PyPI or install via pip install ScopeFoundry.\n","categories":"","description":"Instructions for ScopeFoundry Development on macOS and Linux.","excerpt":"Instructions for ScopeFoundry Development on macOS and Linux.","ref":"/docs/advanced-dev/mac-linux/","tags":"","title":"MacOS and Linux"},{"body":"Recommendation This feature works best if the machine you are working on has Jupyter notebook installed such that double-clicking opens it. One recommended way:\nInstall Visual Studio Code Install extensions: Pylance (Microsoft) Jupyter (Microsoft) Select ScopeFoundry interpreter Trigger feature There are 2 ways to start that feature. Either way, the feature acts on a folder that contains (itself or its subdirectories) .h5 files\nFrom ScopeFoundry: Advanced -\u003e analyze with ipynb. The folder acted upon is the one defined in the app/save_dir settings (bottom left panel)\nUsing ScopeFoundry tools (requires ScopeFoundry 2.0+ see getting started tutorial)\ncd \"to/your_data_folder\" conda activate scopefoundry # or for mac: # source activate scopefoundry python -m ScopeFoundry.tools ​\tand clicking the corresponding button.\nThe result is that it:\nGenerates a h5_data_loaders.py file containing convenience methods based on the .h5 files content Generates an overview.ipynb where you can do the analysis If applicable, will launch VS Code or equivalent. Otherwise, open overview.ipynb manually In cell 1: the necessary imports are done.\nIn cell 2: lines that would load each .h5 file\n","categories":"","description":"Given a folder with .h5 files, use this feature to analyze data quickly. It provides convenient loading functions and an overview Jupyter notebook","excerpt":"Given a folder with .h5 files, use this feature to analyze data …","ref":"/docs/guides/analyze-with-ipynb/","tags":"","title":"Analyze with ipynb"},{"body":"ScopeFoundry provides a DataBrowserApp that makes it easy for a user to explore a set of experiemental results on their computer. It is a plug-in based application, where data-type plug-ins (a DataBrowserView) can show relevant data within the file. The [FoundryDataBrowser] project is an example of the ScopeFoundry DataBrowser with a number of Views used to browse common experiemental data the Molecular Foundry.\nRequirements: install scope_foundry\nSteps\nMake an app Make a image viewer example that show images Make a .h5 viewer that handles your costume file format and displays the data as you like. ","categories":"","description":"Low level reference docs for your project.","excerpt":"Low level reference docs for your project.","ref":"/docs/12_databrowser-tutorials/","tags":"","title":"DataBrowser Tutorials"},{"body":"We will be describing how to build the number_gen_readout measurement that works together with ScopeFoundryHW package we made in the previous example. When run, this measurement periodically samples values from the number_gen hardware component.\nEssential components A ScopeFoundry Measurement is defined as a sub-class of ScopeFoundry.Measurement and has a name:\nimport time import numpy as np from ScopeFoundry import Measurement, h5_io class NumberGenReadoutSimple(Measurement): name = \"number_gen_readout_simple\" Then we override setup() and run() functions that define the measurement. Starting with:\ndef setup(self): \"\"\" Runs once during App initialization. This is the place to load a user interface file, define settings, and set up data structures. \"\"\" s = self.settings s.New(\"sampling_period\", float, initial=0.1, unit=\"s\") s.New(\"N\", int, initial=101) s.New(\"save_h5\", bool, initial=True) To define 3 parameters that will be used during the measurement. When a measurement is started, a new thread is launched, within which eventually the run() function is called, let’s override it to\nSample values from the “number_gen” hardware component Save it to a h5 file (if user desires) def run(self): \"\"\" Runs when measurement is started. Runs in a separate thread from GUI. It should not update the graphical interface directly, and should only focus on data acquisition. \"\"\" # prepare an array for data in memory. self.data = np.ones(self.settings[\"N\"]) # get a reference to the hardware self.hw = self.app.hardware[\"number_gen\"] # N-times sampling the hardware for values for i in range(self.settings[\"N\"]): self.data[i] = self.hw.settings.sine_data.read_from_hardware() time.sleep(self.settings[\"sampling_period\"]) self.set_progress(i * 100.0 / self.settings[\"N\"]) if self.interrupt_measurement_called: break interrupt_measurement_called flag is set to True when the user stops the measurement. Here it breaks out the loop as the measurement spends most of its time there Using set_progress() update the progress bar and also calculates an estimated time until the measurement is done based on the time it started and the progress percentage you set. Finally, some boilerplate code at the end of a measurement, that saves the data and all the settings of the app:\nif self.settings[\"save_h5\"]: # open a file self.h5_file = h5_io.h5_base_file(app=self.app, measurement=self) # create a measurement H5 group (folder) within self.h5file # This stores all the measurement meta-data in this group self.h5_group = h5_io.h5_create_measurement_group( measurement=self, h5group=self.h5_file ) # dump the data set and close the file. self.h5_group.create_dataset(name=\"y\", data=self.data) self.h5_file.close() This completes a measurement.\nThe case for using self.settings When saving data as written above, the values are added to the resulting file which is useful To analyze data User can drag and drop the file on the app to reload the value and bring ScopeFoundry to the same state ScopeFoundry already generates widgets in the tree left that user can use to set values Coherent way to access settings in other components. For example, here we referenced a setting from the “number_gen” hardware component, asked it to update itself and retrieved a value Easy way to generate GUI and connect to widget in GUIs as you will see next Adding a graphical user interface We use two Qt based libraries to create the UI, let’s import them on top of the file.\nimport pyqtgraph as pg from qtpy import QtCore, QtWidgets The GUI should be created at start-up, hence override the setup_figure function (that gets called after the setup function). ScopeFoundry expects that setup_figure defines self.ui with a widget.\nHere we define the GUI programmatically, alternatively one can use Qt-Creator, see below):\ndef setup_figure(self): self.ui = QtWidgets.QWidget() QtWidgets.QWidget() is an empty widget.\nTo add widget onto self.ui one must a layout. (In Qt world one cannot add widget directly on a widget)\nlayout = QtWidgets.QVBoxLayout() self.ui.setLayout(layout) The type of layout defines how added widgets are arranged. Here, QVBoxLayout stacks them vertically. ScopeFoundry provides convenience methods to create widgets that out of the box update when settings values change and conversely change the settings value when its corresponding widget is changed. Let’s add widgets for the settings defined in the setup function and a start/stop button to the layout\nlayout.addWidget(self.settings.New_UI(include=(\"sampling_period\", \"N\", \"save_h5\"))) layout.addWidget(self.new_start_stop_button()) Finally let’s add the plot widget, with axes and a line:\nself.graphics_widget = pg.GraphicsLayoutWidget(border=(100, 100, 100)) self.plot = self.graphics_widget.addPlot(title=self.name) self.plot_lines = {} self.plot_lines[\"y\"] = self.plot.plot(pen=\"g\") layout.addWidget(self.graphics_widget) ScopeFoundry calls update_display() repeatedly during a measurement. Let’s override it:\ndef update_display(self): self.plot_lines[\"y\"].setData(self.data[\"y\"]) Note you do not have to call update_display yourself, you can control the frequency it gets called with self.display_update_period attribute.\nPutting everything together We place a number_gen_readout_simple.py next to the fancy_app.py.\n# number_gen_readout_simple.py import time import numpy as np import pyqtgraph as pg from qtpy import QtCore, QtWidgets from ScopeFoundry import Measurement, h5_io class NumberGenReadoutSimple(Measurement): name = \"number_gen_readout_simple\" def setup(self): \"\"\" Runs once during App initialization. This is the place to load a user interface file, define settings, and set up data structures. \"\"\" s = self.settings s.New(\"sampling_period\", float, initial=0.1, unit=\"s\") s.New(\"N\", int, initial=101) s.New(\"save_h5\", bool, initial=True) def run(self): \"\"\" Runs when measurement is started. Runs in a separate thread from GUI. It should not update the graphical interface directly, and should only focus on data acquisition. \"\"\" # prepare an array for data in memory. self.data = np.ones(self.settings[\"N\"]) # get a reference to the hardware self.hw = self.app.hardware[\"number_gen\"] # N-times sampling the hardware for values for i in range(self.settings[\"N\"]): self.data[i] = self.hw.settings.sine_data.read_from_hardware() time.sleep(self.settings[\"sampling_period\"]) self.set_progress(i * 100.0 / self.settings[\"N\"]) if self.interrupt_measurement_called: break if self.settings[\"save_h5\"]: # open a file self.h5_file = h5_io.h5_base_file(app=self.app, measurement=self) # create a measurement H5 group (folder) within self.h5file # This stores all the measurement meta-data in this group self.h5_group = h5_io.h5_create_measurement_group( measurement=self, h5group=self.h5_file ) # dump the data set and close the file self.h5_group.create_dataset(name=\"y\", data=self.data) self.h5_file.close() def setup_figure(self): \"\"\" Runs once during App initialization and is responsible to create widget self.ui. \"\"\" self.ui = QtWidgets.QWidget() layout = QtWidgets.QVBoxLayout() self.ui.setLayout(layout) layout.addWidget(self.settings.New_UI(include=(\"sampling_period\", \"N\", \"save_h5\"))) layout.addWidget(self.new_start_stop_button()) self.graphics_widget = pg.GraphicsLayoutWidget(border=(100, 100, 100)) self.plot = self.graphics_widget.addPlot(title=self.name) self.plot_lines = {\"y\": self.plot.plot(pen=\"g\")} layout.addWidget(self.graphics_widget) def update_display(self): self.plot_lines[\"y\"].setData(self.data) We add this Measurement to the app using add_measurement() method:\n# fancy_app.py import sys from ScopeFoundry import BaseMicroscopeApp class FancyApp(BaseMicroscopeApp): name = \"fancy app\" def setup(self): from ScopeFoundryHW.random_number_gen import NumberGenHw self.add_hardware(NumberGenHw(self)) from number_gen_readout_simple import NumberGenReadoutSimple self.add_measurement(NumberGenReadoutSimple(self)) if __name__ == \"__main__\": app = FancyApp(sys.argv) # app.settings_load_ini(\"default_settings.ini\") sys.exit(app.exec_()) As usual this can be run with:\n$ python fancy_app.py next tutorial\nAlternative: Build the user interface with qt-creator In the above implementation we created the figure programmatically. However, we could also create use the qt creator to design a user interface.\nDownload the free Qt Creator Create .ui file. The one used here, number_gen_readout.ui, can be found in the tutorial repository. Save the ui file next to the measurement file (sibling path) Adjust the setup_figure() method of the measurement def setup_figure(self): \"\"\" Runs once during App initialization, after setup() This is the place to make all graphical interface initializations, build plots, etc. \"\"\" self.ui_filename = sibling_path(__file__, \"number_gen_readout.ui\") self.ui = load_qt_ui_file(self.ui_filename) # connect ui widgets to measurement/hardware settings or functions self.settings.activation.connect_to_pushButton(self.ui.start_pushButton) self.settings.save_h5.connect_to_widget(self.ui.save_h5_checkBox) self.hw.settings.amplitude.connect_to_widget(self.ui.amp_doubleSpinBox) # Set up pyqtgraph graph_layout in the UI self.graph_layout=pg.GraphicsLayoutWidget() self.ui.plot_groupBox.layout().addWidget(self.graph_layout) # Create PlotItem object (a set of axes) self.plot = self.graph_layout.addPlot(title=self.name) # Create PlotDataItem object ( a scatter plot on the axes ) self.plot_lines = {\"y\": self.plot.plot(pen=\"g\")} The resulting app should look like (using dated version of ScopeFoundry):\nBonus 1: Analyzed with ipynb Clicking the analyze button on the left panel one can quickly start to analyze the data. For this feature it is recommended to install Visual Studio Code with the Jupyter extension.\nsee more details about this feature\nBonus 2: Improved version In the above example kept things simple. We made some modifications in this final version that has the following improvements:\nrun Measurement runs indefinitely or until the user hits stop Data is dumped to the file during the measurement ensuring that data is stored if the program crashes setup_figure Uses splitter instead of QVBoxLayout Includes settings from the hw # number_gen_readout.py import time import numpy as np import pyqtgraph as pg from qtpy import QtCore, QtWidgets from ScopeFoundry import Measurement, h5_io class NumberGenReadout(Measurement): name = \"number_gen_readout\" def setup(self): \"\"\" Runs once during App initialization. This is the place to load a user interface file, define settings, and set up data structures. \"\"\" s = self.settings s.New(\"sampling_period\", float, initial=0.1, unit=\"s\") s.New(\"N\", int, initial=101) s.New(\"save_h5\", bool, initial=True) # data structure of the measurement self.data = {\"y\": np.ones(101)} # link to previous functions self.hw = self.app.hardware[\"number_gen\"] def setup_figure(self): \"\"\" Runs once during App initialization and is responsible to create widget self.ui. here we create the ui figure programmatically, for an alternative using qt creator see bellow. \"\"\" # make a layout that holds all measurement controlls and settings from hardware cb_layout = QtWidgets.QHBoxLayout() cb_layout.addWidget(self.new_start_stop_button()) cb_layout.addWidget( self.settings.New_UI( exclude=(\"activation\", \"run_state\", \"profile\", \"progress\") ) ) # add hardware settings to the layout cb_layout.addWidget(self.hw.settings.New_UI(exclude=(\"debug_mode\", \"connected\", \"port\"))) header_widget = QtWidgets.QWidget() header_layout = QtWidgets.QVBoxLayout(header_widget) header_layout.addLayout(cb_layout) # make a plot widget that containing a one line self.graphics_widget = pg.GraphicsLayoutWidget(border=(100, 100, 100)) self.plot = self.graphics_widget.addPlot(title=self.name) self.plot_lines = {} self.plot_lines[\"y\"] = self.plot.plot(pen=\"g\") # putting everything together # ScopeFoundry assumes .ui is the main widget: self.ui = QtWidgets.QSplitter(QtCore.Qt.Orientation.Vertical) self.ui.addWidget(header_widget) self.ui.addWidget(self.graphics_widget) def setup_h5_file(self): # This stores all the hardware and app meta-data in the H5 file self.h5file = h5_io.h5_base_file(app=self.app, measurement=self) # create a measurement H5 group (folder) within self.h5file # This stores all the measurement meta-data in this group self.h5_group = h5_io.h5_create_measurement_group( measurement=self, h5group=self.h5file ) # create an h5 dataset to store the data dset = self.data[\"y\"] self.h5_y = self.h5_group.create_dataset( name=\"y\", shape=dset.shape, dtype=dset.dtype ) def run(self): \"\"\" Runs when measurement is started. Runs in a separate thread from GUI. It should not update the graphical interface directly, and should only focus on data acquisition. \"\"\" # a buffer in memory for data self.data[\"y\"] = np.ones(self.settings[\"N\"]) if self.settings[\"save_h5\"]: self.setup_h5_file() # We use a try/finally block, so that if anything goes wrong during a measurement, # the finally block can clean things up, e.g. close the data file object. try: i = 0 # Will run forever until interrupt is called. while not self.interrupt_measurement_called: i %= len(self.h5_y) # Set progress bar percentage complete self.set_progress(i * 100.0 / self.settings[\"N\"]) # Fills the buffer with sine wave readings from func_gen Hardware self.data[\"y\"][i] = self.hw.settings.sine_data.read_from_hardware() if self.settings[\"save_h5\"]: # if we are saving data to disk, copy data to H5 dataset self.h5_y[i] = self.data[\"y\"][i] # flush H5 self.h5file.flush() # wait between readings. # We will use our sampling_period settings to define time time.sleep(self.settings[\"sampling_period\"]) i += 1 if self.interrupt_measurement_called: # Listen for interrupt_measurement_called flag. # This is critical to do, if you don't the measurement will # never stop. # The interrupt button is a polite request to the # Measurement thread. We must periodically check for # an interrupt request break finally: print(\"NumberGenReadout: Finishing\") if self.settings[\"save_h5\"]: # make sure to close the data file self.h5file.close() def update_display(self): \"\"\" Function is called repeatedly at an interval defined by `self.display_update_period` (in seconds). This value is set by default to 0.1 seconds, but can be updated in `setup_figure()`. Since we created all the plot objects during `setup_figure()` this `update_display()` function can be quite simple. Here we update the `self.plot_lines[\"y\"]` using the data in `self.data['y']`, which is being filled by the Measurement `run()` thread. \"\"\" self.plot_lines[\"y\"].setData(self.data[\"y\"]) Result of improved version: next tutorial\n","categories":"","description":"Learn how to build a custom Measurement and how to get started analyzing the data","excerpt":"Learn how to build a custom Measurement and how to get started …","ref":"/docs/10_tutorials/3_measurement/","tags":"","title":"Measurement Component"},{"body":"Here we discuss how to build a custom hardware plug-in for ScopeFoundry. If one is not available in our list of plug-ins, you can build one based on this tutorial. We will do this through 3 sections: First make a low-level python interface to the device, second write a ScopeFoundry HardwareComponent, and finally package up the result to share with the ScopeFoundry project and other users.\nLow-level device interface Most scientific devices have programmatic ways to communicate to them, either through a vendor-povided API that talks to a device driver, or a communications protocol for a device connected by a standard communication pathway (RS232 serial, Ethernet, modbus etc)\nThe manufacturer often provides the commands needed for the computer to talk with your hardware. You should find your device’s communication protocol within the provided manufacturer documentation, hopefully reverse engineering a communication protocol is not required!\nThe first step to controlling a device with ScopeFoundry is to create a convienient Python wrapper for the device, if one does not yet exist. We do this by wrapping the hardware functionality that we require in to a python object class. This low-level code is not dependent on ScopeFoundry, and is not required for building a hardware plugin, but illustrates good encapsulation of hardware functionality into a python object.\nimport numpy as np import time class RandomNumberGenDev(object): \"\"\" This is the low level dummy device object. Typically when instantiated it will connect to the real-world Methods allow for device read and write functions \"\"\" def __init__(self, amplitude=1.0): \"\"\"We would connect to the real-world here if this were a real device \"\"\" self.write_amp(amplitude) def write_amp(self, amplitude): \"\"\" A write function to change the device's amplitude normally this would talk to the real-world to change a setting on the device \"\"\" self._amplitude = amplitude def read_rand_num(self): \"\"\" Read function to access a Random number generator. Acts as our scientific device picking up a lot of noise. \"\"\" rand_data = np.random.ranf() * self._amplitude return rand_data def read_sine_wave(self): \"\"\" Read function to access a sine wave. Acts like the device is generating a 1Hz sine wave with an amplitude set by write_amp \"\"\" sine_data = np.sin(time.time()) * self._amplitude return sine_data When we create an instance of this device class, we begin communication to the device. Other methods with names starting with read_ or write_ are the messages we can pass back and forth to the device.\nIn this case we defined a method read_rand_num which uses a random number generator from numpy and returns a random value every time it’s called. This function is referenced in the hardware plugin section below code.\nIn the case where you would like to connect to real scientific equipment and define basic functions based on its communication protocol, I would recommend the following:\nDefine whichever addresses and ports you would like to use using variables defined in the module’s __init__() method. Then define a write function which can send messages to the device over RS232, Ethernet, via DLL or other protocol as required. Hardware Plug-in The next step is to create the HardwareComponent ScopeFoundry plug-in. Here we sub-class HardwareComponent and define three methods: setup(), connect(), and disconnect():\nfrom ScopeFoundry import HardwareComponent # import our low level device object class (previous section) from ScopeFoundryHW.random_gen import RandomNumberGenDev class RandomNumberGenHW(HardwareComponent): ## Define name of this hardware plug-in name = 'random_gen' def setup(self): # Define your hardware settings here. # These settings will be displayed in the GUI and auto-saved with data files self.settings.New(name='amplitude', initial=1.0, dtype=float, ro=False) self.settings.New(name='rand_data', initial=0, dtype=float, ro=True) self.settings.New(name=\"sine_data\", initial=0, dtype=float, ro=True) def connect(self): # Open connection to the device: self.randgen_dev = RandomNumberGenDev(amplitude=self.settings['amplitude']) # Connect settings to hardware: self.settings.amplitude.connect_to_hardware( write_func = self.randgen_dev.write_amp) self.settings.rand_data.connect_to_hardware( read_func = self.randgen_dev.read_rand_num) self.settings.sine_data.connect_to_hardware( read_func = self.randgen_dev.read_sine_wave) #Take an initial sample of the data. self.read_from_hardware() def disconnect(self): # remove all hardware connections to settings self.settings.disconnect_all_from_hardware() # Don't just stare at it, clean up your objects when you're done! if hasattr(self, 'randgen_dev'): del self.randgen_dev There are several critical components contained within this module which essentially handle signals, settings, and links to low level device functions.\nFor the sake of simplicity we’ve omitted hardware level signals in this basic tutorial.\nclass: We make our module a subclass of HardwareComponent. setup()\nHere we set up a few settings for this hardware, these settings are LoggedQuantity objects that contain a hardware value that can read or written. This object helps keep this value in sync between hardware, measurement and graphical interface. connect()\nWe define an object self.randgendev which instantiates the low-level device wrapper and thereby accesses hardware functions. Using connect_to_hardware() we to the device level self.randgendev.rand_func. Every time the we call rand_data.read_from_hardware() is called, the linked functions will be called. We run self.read_from_hardware() to update all hardware-connected settings with initial readout values. disconnect()\nWe clean up the mess we made by removing objects after use. By having the connect() and disconnect() we can cleanly reconnect hardware during an App run. This is especially useful when debugging a hardware plug-in to a new device.\nPackaging If you would like to include your shiny new plugin as a ScopeFoundryHW plug-in, ie sharing the ScopeFoundryHW package name and hosting it on github.com/scopefoundry. Here are some tips:\nUse the example plug-in HW_random_gen as an example. It includes a README.md, LICENSE, and setup.py files required to make a plug-in package.\nMapping of module name to github repo name:\nPython package name ScopeFoundryHW.hw_plugin_name Repo Location https://github.com/ScopeFoundry/HW_hw_plugin_name The setup.py tells pip how to install your plug-in, along with meta-data about the plug-in. Here is the setup.py from HW_random_gen:\nfrom setuptools import setup setup( name = 'ScopeFoundryHW.random_gen', version = '0.0.1', description = 'ScopeFoundry Hardware plug-in: Dummy random number generator', # Author details author='Edward S. Barnard', author_email='esbarnard@lbl.gov', # Choose your license license='BSD', package_dir={'ScopeFoundryHW.random_gen': '.'}, packages=['ScopeFoundryHW.random_gen',], #packages=find_packages('.', exclude=['contrib', 'docs', 'tests']), #include_package_data=True, package_data={ '':[\"*.ui\"], # include QT ui files '':[\"README*\", 'LICENSE'], # include License and readme }, ) If you would like to contribute a plug-in to ScopeFoundry, please do! Contact the maintainers on our project mailing list.\nWhere to Find Out More This tutorial code is available in the HW_random_gen repository.\nFor questions about this tutorial or ScopeFoundry in general, please visit and post on the ScopeFoundry project mailing list and forum.\nFor source code of all ScopeFoundry projects visit our GitHub page.\n","categories":"","description":"Hardware device doesn't have a ScopeFoundry plugin? Learn to create and share your own!","excerpt":"Hardware device doesn't have a ScopeFoundry plugin? Learn to create …","ref":"/docs/tutorials/hardware-plugin/","tags":"","title":"Create a Custom Hardware Plug-in"},{"body":"Install Anaconda 3 (Python latest version), only for your Windows User (who must be an Administrator), not for everyone. Pick a good directory, sometimes it will try to install deep within LocalSettings\nSet up Anaconda Enviroment conda create --name scopefoundry anaconda=2019.07 conda activate scopefoundry Install Git for example using conda install git, or using the Source Tree software) and configure it.\nRemember to configure your git user info:\ngit config --global user.name \"Nobody Nobinov\"` git config --global user.email \"nnobinov@example.com\"` Setup Experiment Repository Tree structure of a typical experiment repository\n├── .git/\t# Stores Git repository information │ └── ... ├── ScopeFoundry/\t# Local Sub-tree of ScopeFoundry │ └── ... ├── ScopeFoundryHW/\t# Local copies of ScopeFoundry hardware plugins │ ├── virtual_function_gen/\t# Local sub-tree of specific hardware plugin │ └── ... └── microscope_app.py Create a folder (main folder) where you are going to put the ScopeFoundry code. Open Anaconda Prompt (or Terminal) and go to that folder\nSet up git repo: git init copy nul __init__.py (this creates an empy file called __init__.py in the main folder) git add -A git commit –m \"New repository\" (the commit of at least one file is necessary before running the following commands) Include ScopeFoundry as a subtree git subtree add --prefix ScopeFoundry https://github.com/ScopeFoundry/ScopeFoundry.git master (this will add a copy of ScopeFoundry to the main folder) Grab Hardware plugins from ScopeFoundry’s github page: git subtree add --prefix ScopeFoundryHW/virtual_function_gen/ https://github.com/ScopeFoundry/HW_virtual_function_gen.git master (this will add a particular Harware to the ScopeFoundryHW folder) To update ScopeFoundry to the latest version: git subtree pull --prefix ScopeFoundry https://github.com/ScopeFoundry/ScopeFoundry.git master\nInstall Eclipse Eclipse will require a Java Development Kit (JDK), to be installed or upgraded.\nDuring installation of Eclipse select Eclipse for Java Developers.\nNote: A useful way to automatically install eclipse: use https://ninite.com/. Select Eclipse and JDK (AdoptOpenJDK) x64 11\nSetup Eclipse with PyDev INSTALL PyDev in Eclipse.\nUse Help-\u003eMarketplace to install PyDev. SET THE PYTHON INTERPRETER IN ECLIPSE:\nOpen Eclipse, close Welcome page\n(Windows-\u003ePreference-\u003ePyDev-\u003eInterpreters-\u003ePhyton Interpreters -\u003eNew… -\u003eBrowse-\u003eSelect python.exe in Anaconda 3 folder)\nUnder “Package” tab, select “Load conda var before run?”\nUnderv “Environment package” add variable CONDA_DLL_SEARCH_MODIFICATION_ENABLE, setting value = 1\nSetup the Python Project in Eclipse one of the two following ways:\nCreate A New Project\nCreate a python project in Eclipse (New-\u003eOther-\u003ePyDev-\u003ePyDevProject) and add a new .py file to the project. Make sure to select “Add project directory to the PYTHONPATH” Use An Existing Code\nFile -\u003e Open Project From Filesystem Select the directory where your phyton code is. Right click on the newly created folder in Eclipse, select PyDev-\u003e Set As PyDev Project Right click on the newly created folder in Eclipse, select PyDev-\u003e Set as folder in PYTHONPATH QT Creator INSTALL QT Creator (use default options). This for interactive creation of QT user interface files (.ui) More Information Other ScopeFoundry resources are available on: https://bitbucket.org/berkeleylab/foundry_scope/src/master/ ","categories":"","description":"Instructions for ScopeFoundry Development on Windows.","excerpt":"Instructions for ScopeFoundry Development on Windows.","ref":"/docs/advanced-dev/windows/","tags":"","title":"Step-by-Step on Windows"},{"body":"Lets define a custom view. We do this by subclassing the DataBrowserView class. Three methods should be defined setup(), is_file_supported(), and on_change_data_filename().\nHere is an example of a simple dataviewer that uses a PyQtGraph ImageView to display an image loaded via matplotlib. Create a file in a subfolderviewers/images.py\n# viewers/images.py import os import numpy as np import pyqtgraph as pg from matplotlib.pyplot import imread from ScopeFoundry.data_browser import DataBrowserView class MatplotlibImreadView(DataBrowserView): # This name is used in the GUI for the DataBrowser name = \"matplot_imread_view\" def setup(self): # create the GUI and viewer settings, runs once at program start up # self.ui should be a QWidget of some sort, here we use a pyqtgraph ImageView self.ui = self.imview = pg.ImageView() def is_file_supported(self, fname): # Tells the DataBrowser whether this plug-in would likely be able # to read the given file name # here we are using the file extension to make a guess _, ext = os.path.splitext(fname) return ext.lower() in [\".png\", \".tif\", \".tiff\", \".jpg\"] def on_change_data_filename(self, fname): # A new file has been selected by the user, load and display it try: self.data = imread(fname) self.imview.setImage(self.data.swapaxes(0, 1)) except Exception as err: # When a failure to load occurs, zero out image # and show error message self.imview.setImage(np.zeros((10, 10))) self.databrowser.ui.statusbar.showMessage( \"failed to load %s:\\n%s\" % (fname, err) ) raise (err) Adding the view Add these line to your fancy_data_browser.py file created earlier\nfrom viewers.images import MatplotlibImreadView app.add_view(MatplotlibImreadView(app)) The folder structure should be of this form:\n├── your_project_folder ... ├── viewers.py ├── images.py ├── fancy_data_browser.py Here is a resulting screen shot of running this data browser script and navigating to a folder with a png image.\n","categories":"","description":"Learn how to create custom DataBrowserView applications","excerpt":"Learn how to create custom DataBrowserView applications","ref":"/docs/12_databrowser-tutorials/2_data-browser-viewer/","tags":"","title":"ImageRead Viewer"},{"body":"ScopeFoundry provides a DataBrowserApp that makes it easy for a user to explore a set of experiemental results on their computer. It is a plug-in based application, where data-type plug-ins (a DataBrowserView) can show relevant data within the file. The [FoundryDataBrowser] project is an example of the ScopeFoundry DataBrowser with a number of Views used to browse common experiemental data the Molecular Foundry.\nSetup Note: We recommend the Anaconda python distribution, which contains many easy to install scientific python packages.\nDownload and Install Anaconda. Recommended python version is 3.5.\nCreate an conda environment includes ScopeFoundry and its dependencies. Open an Anaconda prompt and run the following commands:\n$ conda create -n scopefoundry python=3.6 anaconda $ source activate scopefoundry (scopefoundry) $ conda install pyqtgraph (scopefoundry) $ pip install ScopeFoundry Note: On Windows source activate scopefoundry should be replaced by activate scopefoundry\nDefining a DataBrowserView Lets define a custom view. We do this by subclassing the DataBrowserView class. Three methods should be defined setup(), is_file_supported(), and on_change_data_filename().\nHere is an example of a simple dataviewer that uses a PyQtGraph ImageView to display an image loaded via scipy (this file is called viewers/images.py in [FoundryDataBrowser][FoundryDataBrowser]):\nfrom ScopeFoundry.data_browser import DataBrowserView import pyqtgraph as pg import numpy as np from scipy.misc import imread import os #scipy imread uses the Python Imaging Library (PIL) to read an image class ScipyImreadView(DataBrowserView): # This name is used in the GUI for the DataBrowser name = 'scipy_imread_view' def setup(self): # create the GUI and viewer settings, runs once at program start up # self.ui should be a QWidget of some sort, here we use a pyqtgraph ImageView self.ui = self.imview = pg.ImageView() def is_file_supported(self, fname): # Tells the DataBrowser whether this plug-in would likely be able # to read the given file name # here we are using the file extension to make a guess _, ext = os.path.splitext(fname) return ext.lower() in ['.png', '.tif', '.tiff', '.jpg'] def on_change_data_filename(self, fname): # A new file has been selected by the user, load and display it try: self.data = imread(fname) self.imview.setImage(self.data.swapaxes(0,1)) except Exception as err: # When a failure to load occurs, zero out image # and show error message self.imview.setImage(np.zeros((10,10))) self.databrowser.ui.statusbar.showMessage( \"failed to load %s:\\n%s\" %(fname, err)) raise(err) Running your DataBrowser To use this view you can create a DataBrowser script like this:\nfrom ScopeFoundry.data_browser import DataBrowser import sys app = DataBrowser(sys.argv) # views are loaded in order of more generic to more specific. ## ie the last loaded views are checked first for compatibility app.load_view(ScipyImreadView(app)) # More views here sys.exit(app.exec_()) You can download the complete script here: databrowser_example.py\nHere is a resulting screen shot of running this data browser script and navigating to a folder with TIFF images.\nWhere to Find More This example is part of the [FoundryDataBrowser] repository. There are many more examples of DataBrowserViews available for download there.\nFor questions about this tutorial or ScopeFoundry in general, please visit and post on the ScopeFoundry project mailing list / forum\nFor Source Code of all ScopeFoundry sub-projects visit our GitHub page\n","categories":"","description":"Learn how to create custom DataBrowserView applications","excerpt":"Learn how to create custom DataBrowserView applications","ref":"/docs/tutorials/data-browser-plugin/","tags":"","title":"DataBrowser View Plug-in Tutorial"},{"body":"coming soon. will be similar to images tutorial but more more stream lined with analyze with ipynb feature\n","categories":"","description":"Learn how to create custom DataBrowserView for .h5 quickly","excerpt":"Learn how to create custom DataBrowserView for .h5 quickly","ref":"/docs/12_databrowser-tutorials/4_data-browser-viewer-h5/","tags":"","title":"H5 file Viewer"},{"body":"Advanced topic comming soon. See an example at ScopeFoundry.data_browser.plug_ins.h5_search\n","categories":"","description":"Learn how to setup Data-Browser PlugIn","excerpt":"Learn how to setup Data-Browser PlugIn","ref":"/docs/12_databrowser-tutorials/5_data-browser-plugin/","tags":"","title":"PlugIn"},{"body":" This is a placeholder page that shows you how to use this template site.\nIf your project has an API, configuration, or other reference - anything that users need to look up that’s at an even lower level than a single task - put (or link to it) here. You can serve and link to generated reference docs created using Doxygen, Javadoc, or other doc generation tools by putting them in your static/ directory. Find out more in Adding static content. For OpenAPI reference, Docsy also provides a Swagger UI layout and shortcode that renders Swagger UI using any OpenAPI YAML or JSON file as source.\n","categories":"","description":"Hardware components with existing ScopeFoundry plug-ins","excerpt":"Hardware components with existing ScopeFoundry plug-ins","ref":"/docs/reference/hw-components/","tags":"","title":"Hardware Components"},{"body":"The first step to controlling a device with ScopeFoundry is to create a convenient Python wrapper for the device. We do this by wrapping the hardware functionality that we require into a Python object class and we typically store it in a file ending with _dev.py or interface.py. This low-level code is not dependent on ScopeFoundry.\nMost scientific devices have programmatic ways to communicate with them, either through a vendor-provided API that talks to a device driver, or a communications protocol for a device connected by a standard communication pathway (RS232 serial, Ethernet, Modbus, etc.). The manufacturer often provides the commands needed for the computer to talk with your hardware. You should find your device’s communication protocol within the provided manufacturer documentation.\nWe identified three categories of communication types resulting in three kinds of wrappers, how you can identify them and some example of each.\nDLL: Manufacturer provides a DLL basic example: PicoHarp Advanced example (supports) picam SERIAL: Manufacturer provides a list of serial commands (scan the hardware documentation for baud rate) basic example: ActonSpec, TenmaPowre OTHER: Manufacturer provides a Python interface (sometimes called Software Development Kit SDK) or all other cases with a manufactures SDK: Zwoasi with VISA: Thorlabs Powermeter ","categories":"","description":"more on low level interface implementation","excerpt":"more on low level interface implementation","ref":"/docs/10_tutorials/10_hardware-2/","tags":"","title":"Hardware 2 - low level interface"},{"body":"Packaging If you would like to include your shiny new plugin as a ScopeFoundryHW plug-in, ie sharing the ScopeFoundryHW package name and hosting it on github.com/scopefoundry. Here are some tips:\nUse the example plug-in HW_random_gen as an example. It includes a README.md, LICENSE, and setup.py files required to make a plug-in package.\nMapping of module name to github repo name:\nPython package name ScopeFoundryHW.hw_plugin_name Repo Location https://github.com/ScopeFoundry/HW_hw_plugin_name The setup.py tells pip how to install your plug-in, along with meta-data about the plug-in. Here is the setup.py from HW_random_gen:\nfrom setuptools import setup setup( name = 'ScopeFoundryHW.random_gen', version = '0.0.1', description = 'ScopeFoundry Hardware plug-in: Dummy random number generator', # Author details author='Edward S. Barnard', author_email='esbarnard@lbl.gov', # Choose your license license='BSD', package_dir={'ScopeFoundryHW.random_gen': '.'}, packages=['ScopeFoundryHW.random_gen',], #packages=find_packages('.', exclude=['contrib', 'docs', 'tests']), #include_package_data=True, package_data={ '':[\"*.ui\"], # include QT ui files '':[\"README*\", 'LICENSE'], # include License and readme }, ) If you would like to contribute a plug-in to ScopeFoundry, please do! Contact the maintainers on our project mailing list.\nWhere to Find Out More This tutorial code is available in the HW_random_gen repository.\nFor questions about this tutorial or ScopeFoundry in general, please visit and post on the ScopeFoundry project mailing list and forum.\nFor source code of all ScopeFoundry projects visit our GitHub page.\n","categories":"","description":"package a HW component and publish on GitHub","excerpt":"package a HW component and publish on GitHub","ref":"/docs/guides/hardware-packaging-and-publishing/","tags":"","title":"Hardware 3 - Packaging"},{"body":"When creating a new setting one can specify a initial value:\nname = \"noiser_2000\" ... self.settings.New(\"port\", str, initial=\"COM10\") However, you might find that after you started the app the port is now set to “COM7”. Then probably your *app.py file contains a line that loads \"default_settings.ini\" file.\n... if __name__ == \"__main__\": app = FancyApp(sys.argv) app.settings_load_ini(\"default_settings.ini\") sys.exit(app.exec_()) with the default_settings.ini file contains the lines:\n[noiser_2000] port = COM7 so loaded values override initial values. However, there is one exemption, that is when a setting is protected\nself.settings.New(\"z_target_position\", float, initial=0.0, protected=True) Proceted settings were introduced such that loading a file does not accidentally set a value to a dangereous level, like driving a stage into a 10k optical objective.\n","categories":"","description":"loaded values override initial values settings - except when protected","excerpt":"loaded values override initial values settings - except when protected","ref":"/docs/guides/default-values/","tags":"","title":"initial, default and protected values"},{"body":" This is a placeholder page that shows you how to use this template site.\nIf your project has an API, configuration, or other reference - anything that users need to look up that’s at an even lower level than a single task - put (or link to it) here. You can serve and link to generated reference docs created using Doxygen, Javadoc, or other doc generation tools by putting them in your static/ directory. Find out more in Adding static content. For OpenAPI reference, Docsy also provides a Swagger UI layout and shortcode that renders Swagger UI using any OpenAPI YAML or JSON file as source.\n","categories":"","description":"Low level reference docs for your project.","excerpt":"Low level reference docs for your project.","ref":"/docs/reference/","tags":"","title":"Reference"},{"body":"","categories":"","description":"Learn to write your own custom ScopeFoundry hardware and measurement plugins.","excerpt":"Learn to write your own custom ScopeFoundry hardware and measurement …","ref":"/docs/guides/","tags":"","title":"Guides"},{"body":"The measurement will auto-save a data-file that contains the optimizer history to an HDF5 (.h5) data file within the specified Save Directory. This data file contains the data along with data structures that include all the meta-data from the microscope App. To view this data file, we can use a graphical viewer HDFView, or use the FoundryDataBrowser from the ScopeFoundry project.\nThe data file created by the sine_wave_plot measurement has the following hierarchy:\n|\u003e app |- name = vfunc_gen_test_app |- ScopeFoundry_type = App |\u003e settings |- save_dir = ~/fancy_microscope/data |- sample = Test Sample 42 |\u003e units |\u003e hardware |- ScopeFoundry_type = HardwareList |\u003e virtual_function_gen |- name = virtual_function_gen |- ScopeFoundry_type = Hardware |\u003e settings |- connected = True |- debug_mode = False |- amplitude = 1.0 |- rand_data = 0.5191185618096453 |- sine_data = 0.9099735972719286 |- square_data = -1.0 |\u003e units |\u003e measurement |\u003e sine_wave_plot |- name = sine_wave_plot |- ScopeFoundry_type = Measurement |D buffer: (120,) float64 |\u003e settings |- activation = False |- running = True |- progress = 50.0 |- save_h5 = True |- sampling_period = 0.1 |\u003e units |- progress = % |- sampling_period = s You will notice that this data file contains much more than just the sine wave data recorded during your measurement. It also contains all the settings of the hardware and measurement conditions at the time of the data acquisition.\nWe can access this data file in Python using the h5py package.\nimport h5py dat = h5py.File('1486144636_sine_wave_plot.h5', 'r') sample_name = dat['app/settings'].attrs['sample'] print(sample_name) # Test Sample 42 buffer_data = dat['measurement/sine_wave_plot/buffer'] import matplotlib.pyplot as plt plt.title(sample_name) plt.plot( buffer_data) plt.savefig('sine_wave_data_plot_42.png') plt.show() ","categories":"","description":"Learn to write your own custom ScopeFoundry hardware and measurement plugins.","excerpt":"Learn to write your own custom ScopeFoundry hardware and measurement …","ref":"/docs/guides/h5-file-format/","tags":"","title":".h5 file format"},{"body":"","categories":"","description":"Show your user how to work through some end to end examples.","excerpt":"Show your user how to work through some end to end examples.","ref":"/docs/advanced-dev/","tags":"","title":"Advanced Development"},{"body":"Why ScopeFoundry An example in our lab:\nComponents Needed for Microscope Software A visual guide:\nStructure of a ScopeFoundry Microscope App Syncronized Settings: The LoggedQuantity A central component you will see at all levels of a ScopeFoundry program is a “LoggedQuantity”, an object representation of a hardware or software setting.\nHardware Plug-ins Measurement Modules Data Storage ","categories":"","description":"Slides demonstrating ScopeFoundry Concepts\n","excerpt":"Slides demonstrating ScopeFoundry Concepts\n","ref":"/docs/key-concepts/","tags":"","title":"Key Concepts"},{"body":" This is a placeholder page that shows you how to use this template site.\nTutorials are complete worked examples made up of multiple tasks that guide the user through a relatively simple but realistic scenario: building an application that uses some of your project’s features, for example. If you have already created some Examples for your project you can base Tutorials on them. This section is optional. However, remember that although you may not need this section at first, having tutorials can be useful to help your users engage with your example code, especially if there are aspects that need more explanation than you can easily provide in code comments.\n","categories":"","description":"Learn to write your own custom ScopeFoundry hardware and measurement plugins.","excerpt":"Learn to write your own custom ScopeFoundry hardware and measurement …","ref":"/docs/tutorials/","tags":"","title":"Legacy Tutorials"},{"body":" This is a placeholder page that shows you how to use this template site.\nThis section is where the user documentation for your project lives - all the information your users need to understand and successfully use your project.\nFor large documentation sets we recommend adding content under the headings in this section, though if some or all of them don’t apply to your project feel free to remove them or add your own. You can see an example of a smaller Docsy documentation site in the Docsy User Guide, which lives in the Docsy theme repo if you’d like to copy its docs section.\nOther content such as marketing material, case studies, and community updates should live in the About and Community pages.\nFind out how to use the Docsy theme in the Docsy User Guide. You can learn more about how to organize your documentation (and how we organized this site) in Organizing Your Content.\n","categories":"","description":"","excerpt":" This is a placeholder page that shows you how to use this template …","ref":"/docs/","tags":"","title":"Documentation"},{"body":" ScopeFoundry Learn More Download Porridge temperature assessment — in the cloud!\nGoldydocs provides a single web UI providing visibility into porridge temperature, chair size, and bed softness metrics! You can even find out who’s been eating your porridge.\n(Sadly, Goldydocs isn’t a real project, but you can use this site as an example to create your own real websites with Docsy)\nNew chair metrics! The Goldydocs UI now shows chair size metrics by default.\nPlease follow this space for updates!\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more\nFollow us on Twitter! For announcement of latest features etc.\nRead more\nThis is the second section\nDownload from AppStore Get the Goldydocs app!\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more\nFollow us on Twitter! For announcement of latest features etc.\nRead more\nThis is the another section\n","categories":"","description":"","excerpt":" ScopeFoundry Learn More Download Porridge temperature assessment — in …","ref":"/","tags":"","title":"Goldydocs"},{"body":" This is a placeholder page. Replace it with your own content.\nText can be bold, italic, or strikethrough. Links should be blue with no underlines (unless hovered over).\nThere should be whitespace between paragraphs. Vape migas chillwave sriracha poutine try-hard distillery. Tattooed shabby chic small batch, pabst art party heirloom letterpress air plant pop-up. Sustainable chia skateboard art party banjo cardigan normcore affogato vexillologist quinoa meggings man bun master cleanse shoreditch readymade. Yuccie prism four dollar toast tbh cardigan iPhone, tumblr listicle live-edge VHS. Pug lyft normcore hot chicken biodiesel, actually keffiyeh thundercats photo booth pour-over twee fam food truck microdosing banh mi. Vice activated charcoal raclette unicorn live-edge post-ironic. Heirloom vexillologist coloring book, beard deep v letterpress echo park humblebrag tilde.\n90’s four loko seitan photo booth gochujang freegan tumeric listicle fam ugh humblebrag. Bespoke leggings gastropub, biodiesel brunch pug fashion axe meh swag art party neutra deep v chia. Enamel pin fanny pack knausgaard tofu, artisan cronut hammock meditation occupy master cleanse chartreuse lumbersexual. Kombucha kogi viral truffaut synth distillery single-origin coffee ugh slow-carb marfa selfies. Pitchfork schlitz semiotics fanny pack, ugh artisan vegan vaporware hexagon. Polaroid fixie post-ironic venmo wolf ramps kale chips.\nThere should be no margin above this first sentence.\nBlockquotes should be a lighter gray with a border along the left side in the secondary color.\nThere should be no margin below this final sentence.\nFirst Header 2 This is a normal paragraph following a header. Knausgaard kale chips snackwave microdosing cronut copper mug swag synth bitters letterpress glossier craft beer. Mumblecore bushwick authentic gochujang vegan chambray meditation jean shorts irony. Viral farm-to-table kale chips, pork belly palo santo distillery activated charcoal aesthetic jianbing air plant woke lomo VHS organic. Tattooed locavore succulents heirloom, small batch sriracha echo park DIY af. Shaman you probably haven’t heard of them copper mug, crucifix green juice vape single-origin coffee brunch actually. Mustache etsy vexillologist raclette authentic fam. Tousled beard humblebrag asymmetrical. I love turkey, I love my job, I love my friends, I love Chardonnay!\nDeae legum paulatimque terra, non vos mutata tacet: dic. Vocant docuique me plumas fila quin afuerunt copia haec o neque.\nOn big screens, paragraphs and headings should not take up the full container width, but we want tables, code blocks and similar to take the full width.\nScenester tumeric pickled, authentic crucifix post-ironic fam freegan VHS pork belly 8-bit yuccie PBR\u0026B. I love this life we live in.\nSecond Header 2 This is a blockquote following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nHeader 3 This is a code block following a header. Next level leggings before they sold out, PBR\u0026B church-key shaman echo park. Kale chips occupy godard whatever pop-up freegan pork belly selfies. Gastropub Belinda subway tile woke post-ironic seitan. Shabby chic man bun semiotics vape, chia messenger bag plaid cardigan.\nHeader 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 What Follows A table A header A table A header A table A header There’s a horizontal rule above and below this.\nHere is an unordered list:\nLiverpool F.C. Chelsea F.C. Manchester United F.C. And an ordered list:\nMichael Brecker Seamus Blake Branford Marsalis And an unordered task list:\nCreate a Hugo theme Add task lists to it Take a vacation And a “mixed” task list:\nPack bags ? Travel! And a nested list:\nJackson 5 Michael Tito Jackie Marlon Jermaine TMNT Leonardo Michelangelo Donatello Raphael Definition lists can be used with Markdown syntax. Definition headers are bold.\nName Godzilla Born 1952 Birthplace Japan Color Green Tables should have bold headings and alternating shaded rows.\nArtist Album Year Michael Jackson Thriller 1982 Prince Purple Rain 1984 Beastie Boys License to Ill 1986 If a table is too wide, it should scroll horizontally.\nArtist Album Year Label Awards Songs Michael Jackson Thriller 1982 Epic Records Grammy Award for Album of the Year, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Selling Album, Grammy Award for Best Engineered Album, Non-Classical Wanna Be Startin’ Somethin’, Baby Be Mine, The Girl Is Mine, Thriller, Beat It, Billie Jean, Human Nature, P.Y.T. (Pretty Young Thing), The Lady in My Life Prince Purple Rain 1984 Warner Brothers Records Grammy Award for Best Score Soundtrack for Visual Media, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Soundtrack/Cast Recording, Grammy Award for Best Rock Performance by a Duo or Group with Vocal Let’s Go Crazy, Take Me With U, The Beautiful Ones, Computer Blue, Darling Nikki, When Doves Cry, I Would Die 4 U, Baby I’m a Star, Purple Rain Beastie Boys License to Ill 1986 Mercury Records noawardsbutthistablecelliswide Rhymin \u0026 Stealin, The New Style, She’s Crafty, Posse in Effect, Slow Ride, Girls, (You Gotta) Fight for Your Right, No Sleep Till Brooklyn, Paul Revere, Hold It Now, Hit It, Brass Monkey, Slow and Low, Time to Get Ill Code snippets like var foo = \"bar\"; can be shown inline.\nAlso, this should vertically align with this and this.\nCode can also be shown in a block element.\nfoo := \"bar\"; bar := \"foo\"; Code can also use syntax highlighting.\nfunc main() { input := `var foo = \"bar\";` lexer := lexers.Get(\"javascript\") iterator, _ := lexer.Tokenise(nil, input) style := styles.Get(\"github\") formatter := html.New(html.WithLineNumbers()) var buff bytes.Buffer formatter.Format(\u0026buff, style, iterator) fmt.Println(buff.String()) } Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. Inline code inside table cells should still be distinguishable.\nLanguage Code Javascript var foo = \"bar\"; Ruby foo = \"bar\"{ Small images should be shown at their actual size.\nLarge images should always scale down and fit in the content container.\nThe photo above of the Spruce Picea abies shoot with foliage buds: Bjørn Erik Pedersen, CC-BY-SA.\nComponents Alerts This is an alert. Note This is an alert with a title. Note This is an alert with a title and Markdown. This is a successful alert. This is a warning. Warning This is a warning with a title. Another Heading ","categories":"","description":"A short lead description about this content page. It can be **bold** or _italic_ and can be split over multiple paragraphs.\n","excerpt":"A short lead description about this content page. It can be **bold** …","ref":"/docs/reference/parameter-reference/","tags":"","title":"Parameter Reference"},{"body":" About Goldydocs A sample site using the Docsy Hugo theme.\nGoldydocs is a sample site using the Docsy Hugo theme that shows what it can do and provides you with a template site structure. It’s designed for you to clone and edit as much as you like. See the different sections of the documentation and site for more ideas.\nThis is another section This is another section ","categories":"","description":"","excerpt":" About Goldydocs A sample site using the Docsy Hugo theme.\nGoldydocs …","ref":"/about/","tags":"","title":"About Goldydocs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/community/","tags":"","title":"Community"},{"body":"HW_acton_spec GitHub Repository Last Updated: 2023-12-17T10:15:42Z Readme ScopeFoundryHW.acton_spec Princeton Instruments / Acton 2300i Spectrometer plug-in for ScopeFoundry.\nThis interface uses the RS-232 or USB-serial interface to Acton spectrometers\nIt has been tested with Acton 2300i and 300 series spectrometers\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by Princeton Instruments, Inc.\nAuthors Edward S. Barnard esbarnard@lbl.gov\nRequirements * ScopeFoundry * PySerial ","categories":"","description":"Acton Spectrometer 2300i ScopeFoundry Hardware Component","excerpt":"Acton Spectrometer 2300i ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_acton_spec/","tags":"","title":"HW_acton_spec"},{"body":"HW_andor_camera GitHub Repository Last Updated: 2024-08-12T00:29:30Z Readme README could not be retrieved.\n","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_andor_camera/","tags":"","title":"HW_andor_camera"},{"body":"HW_andor_spec GitHub Repository Last Updated: 2024-08-12T00:45:08Z Readme README could not be retrieved.\n","categories":"","description":"Andor Spectrometer ScopeFoundry Hardware Component","excerpt":"Andor Spectrometer ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_andor_spec/","tags":"","title":"HW_andor_spec"},{"body":"HW_ascom_camera GitHub Repository Last Updated: 2024-08-12T01:05:28Z Readme ScopeFoundryHW.ascom_camera ScopeFoundry hardware plug-in for ASCOM-connected cameras.\nThis interface uses commuicates via ASCOM to many scientific and astronomy camera systems.\nWindows-only due to ASCOM use of the Microsoft COM interface.\n(Tested with a QSI-600 camera)\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by the ASCOM Initiative.\nAuthor Edward S. Barnard esbarnard@lbl.gov\nLicense Keywords Camera, CCD\nRequirements * [ScopeFoundry](http://www.scopefoundry.org) * [pywin32](https://sourceforge.net/projects/pywin32/) * [ASCOM](http://www.ascom-standards.org) * Windows XP or later ","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_ascom_camera/","tags":"","title":"HW_ascom_camera"},{"body":"HW_asi_stage GitHub Repository Last Updated: 2023-09-20T03:25:28Z Readme README could not be retrieved.\n","categories":"","description":"ASI Stage ScopeFoundry Hardware Component","excerpt":"ASI Stage ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_asi_stage/","tags":"","title":"HW_asi_stage"},{"body":"HW_attocube_anc150 GitHub Repository Last Updated: 2017-11-27T20:34:31Z Readme README could not be retrieved.\n","categories":"","description":"Attocube ANC150 open loop stage ScopeFoundry Hardware Component","excerpt":"Attocube ANC150 open loop stage ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_attocube_anc150/","tags":"","title":"HW_attocube_anc150"},{"body":"HW_attocube_ecc100 GitHub Repository Last Updated: 2017-11-27T20:11:16Z Readme README could not be retrieved.\n","categories":"","description":"Attocube ECC100 closed loop stage ScopeFoundry Hardware Component","excerpt":"Attocube ECC100 closed loop stage ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_attocube_ecc100/","tags":"","title":"HW_attocube_ecc100"},{"body":"HW_canon_ccapi GitHub Repository Last Updated: 2024-08-12T00:44:11Z Readme README could not be retrieved.\n","categories":"","description":"Canon Camera Capture (CCAPI) ScopeFoundry Hardware Component","excerpt":"Canon Camera Capture (CCAPI) ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_canon_ccapi/","tags":"","title":"HW_canon_ccapi"},{"body":"HW_crystaltech_aotf GitHub Repository Last Updated: 2024-08-12T00:46:30Z Readme README could not be retrieved.\n","categories":"","description":"CrystalTech AOTF ScopeFoundry Hardware Component","excerpt":"CrystalTech AOTF ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_crystaltech_aotf/","tags":"","title":"HW_crystaltech_aotf"},{"body":"HW_dynamixel_servo GitHub Repository Last Updated: 2024-08-12T00:41:58Z Readme README could not be retrieved.\n","categories":"","description":"Robotis Dynamixel Servo Motor ScopeFoundry Hardware Component","excerpt":"Robotis Dynamixel Servo Motor ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_dynamixel_servo/","tags":"","title":"HW_dynamixel_servo"},{"body":"HW_flircam GitHub Repository Last Updated: 2024-08-12T00:47:58Z Readme README could not be retrieved.\n","categories":"","description":"FLIRCAM Spinnaker API Camera ScopeFoundry Hardware Component","excerpt":"FLIRCAM Spinnaker API Camera ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_flircam/","tags":"","title":"HW_flircam"},{"body":"HW_foundry_data_organizer GitHub Repository Last Updated: 2023-09-05T21:52:56Z ","categories":"","description":"plug in to add proposal identifier to h5 metadata","excerpt":"plug in to add proposal identifier to h5 metadata","ref":"/docs/reference/hw-components/hw_foundry_data_organizer/","tags":"","title":"HW_foundry_data_organizer"},{"body":"HW_igus_dryve GitHub Repository Last Updated: 2024-08-12T00:57:38Z Readme README could not be retrieved.\n","categories":"","description":"Igus Dryve Motion Control ScopeFoundry Hardware Component","excerpt":"Igus Dryve Motion Control ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_igus_dryve/","tags":"","title":"HW_igus_dryve"},{"body":"HW_lambda_zup GitHub Repository Last Updated: 2024-08-12T00:33:19Z Readme README could not be retrieved.\n","categories":"","description":"Lambda Zup Power Supply ScopeFoundry Hardware Component","excerpt":"Lambda Zup Power Supply ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_lambda_zup/","tags":"","title":"HW_lambda_zup"},{"body":"HW_mcl_stage GitHub Repository Last Updated: 2020-12-21T20:34:38Z Readme ScopeFoundryHW.mcl_stage MadCityLabs Piezo USB plug-in for ScopeFoundry.\nThis interface uses the MadLib device driver from MadCityLabs to control MadCityLabs stages controlled by Nano-Drive piezo controllers. To use this, please contact MadCityLabs for the required software and DLL.\nIt has been tested with 2 and 3 axis NanoPDQ stages.\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by MadCityLabs, Inc.\nAuthors Edward S. Barnard esbarnard@lbl.gov\nRequirements * ScopeFoundry ","categories":"","description":"MadCityLabs Nanopositioner Stage ScopeFoundry Hardware component","excerpt":"MadCityLabs Nanopositioner Stage ScopeFoundry Hardware component","ref":"/docs/reference/hw-components/hw_mcl_stage/","tags":"","title":"HW_mcl_stage"},{"body":"HW_newport_esp300 GitHub Repository Last Updated: 2024-08-12T02:07:03Z Readme README could not be retrieved.\n","categories":"","description":"ScopeFoundry Hardware Component for Newport ESP300 motion controller","excerpt":"ScopeFoundry Hardware Component for Newport ESP300 motion controller","ref":"/docs/reference/hw-components/hw_newport_esp300/","tags":"","title":"HW_newport_esp300"},{"body":"HW_ni_daq GitHub Repository Last Updated: 2017-01-10T20:27:05Z Readme ScopeFoundryHW.ni_daq National Instruments data-aquisition plug-in for ScopeFoundry.\nThis interface uses the PyDAQmx wrapper to commuicate with NI DAQmx API, which works with most NI data-aquisition systems.\n(Tested with x-series boards)\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by National Instruments, Inc.\nAuthors D. Frank Ogletree dfogletree@lbl.gov Edward S. Barnard esbarnard@lbl.gov\nRequirements * ScopeFoundry * [PyDAQmx](http://pythonhosted.org/PyDAQmx/) * [NI DAQmx](https://www.ni.com/dataacquisition/nidaqmx.htm) ","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_ni_daq/","tags":"","title":"HW_ni_daq"},{"body":"HW_picam GitHub Repository Last Updated: 2023-01-31T18:27:34Z Readme ScopeFoundryHW.picam ScopeFoundry hardware plug-in to control PICAM based Princeton Instruments Cameras. Tested on a PI PIXIS camera.\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by the device manufacturer\nAuthor Edward S. Barnard esbarnard@lbl.gov\nRequirements * ScopeFoundry * numpy * PICAM DLL History 0.1.0\t2020-08-04\tInitial public release. Plug-in has been used internally and has been stable. Check Git repository for detailed history. Tested on PI PIXIS CCD.\n","categories":"","description":"ScopeFoundry hardware plug-in to control PICAM-based Princeton Instruments Cameras","excerpt":"ScopeFoundry hardware plug-in to control PICAM-based Princeton …","ref":"/docs/reference/hw-components/hw_picam/","tags":"","title":"HW_picam"},{"body":"HW_picoharp GitHub Repository Last Updated: 2017-12-13T17:55:22Z Readme README could not be retrieved.\n","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_picoharp/","tags":"","title":"HW_picoharp"},{"body":"HW_quantum_composer GitHub Repository Last Updated: 2024-08-12T00:40:26Z Readme README could not be retrieved.\n","categories":"","description":"Quantum Composer HW","excerpt":"Quantum Composer HW","ref":"/docs/reference/hw-components/hw_quantum_composer/","tags":"","title":"HW_quantum_composer"},{"body":"HW_random_gen GitHub Repository Last Updated: 2017-01-23T22:17:34Z Readme ScopeFoundryHW.random_gen ScopeFoundry hardware plug-in example that presents a random number generator as a hardware device\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by the device manufacturer\nAuthor Edward S. Barnard esbarnard@lbl.gov and Alan Buckley\nRequirements * ScopeFoundry * numpy ","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_random_gen/","tags":"","title":"HW_random_gen"},{"body":"HW_tenma_power GitHub Repository Last Updated: 2017-11-27T20:35:26Z Readme README could not be retrieved.\n","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_tenma_power/","tags":"","title":"HW_tenma_power"},{"body":"HW_thorlabs_powermeter GitHub Repository Last Updated: 2024-08-12T00:38:50Z Readme ScopeFoundryHW.thorlabs_powermeter Thorlabs PM100D powermeter hardware plug-in for ScopeFoundry.\nThis interface uses the PyVISA 1.5 library to communicate over USB.\nHardware information available from Thorlabs: https://www.thorlabs.com/thorproduct.cfm?partnumber=PM100D\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by Thorlabs, Inc.\nAuthor Edward S. Barnard esbarnard@lbl.gov\nRequirements ScopeFoundry PyVisa Legacy Thorlabs driver How to Install pip install pyvisa\n","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_thorlabs_powermeter/","tags":"","title":"HW_thorlabs_powermeter"},{"body":"HW_virtual_function_gen GitHub Repository Last Updated: 2017-02-03T18:30:05Z Readme ScopeFoundryHW.virtual_function_gen ScopeFoundry hardware plug-in example that virtual function generator as a hardware device. It creates Sine and Square waves\nScopeFoundry is a Python platform for controlling custom laboratory experiments and visualizing scientific data\nhttp://www.scopefoundry.org\nThis software is not made by or endorsed by the device manufacturer\nAuthor Edward S. Barnard esbarnard@lbl.gov and Alan Buckley\nRequirements * ScopeFoundry * numpy ","categories":"","description":"No description available.","excerpt":"No description available.","ref":"/docs/reference/hw-components/hw_virtual_function_gen/","tags":"","title":"HW_virtual_function_gen"},{"body":"HW_zaber_motion GitHub Repository Last Updated: 2024-08-12T00:35:00Z Readme README could not be retrieved.\n","categories":"","description":"Zaber motion control stage ScopeFoundry Hardware Component","excerpt":"Zaber motion control stage ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_zaber_motion/","tags":"","title":"HW_zaber_motion"},{"body":"HW_zeiss_sem GitHub Repository Last Updated: 2024-08-12T00:37:28Z Readme README could not be retrieved.\n","categories":"","description":"Zeiss SEM REMCON32 ScopeFoundry Hardware Component","excerpt":"Zeiss SEM REMCON32 ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_zeiss_sem/","tags":"","title":"HW_zeiss_sem"},{"body":"HW_zwo_camera GitHub Repository Last Updated: 2024-08-12T00:35:51Z Readme uses the python-zwoasi python library and SDK from ZWO\nhttps://github.com/python-zwoasi/python-zwoasi zwoasi-0.1.0.1-py2.py3-none-any.whl\npip install zwoasi On MacOS, the default security settings prevent the SDK library from being accessed\nxattr -d com.apple.quarantine ScopeFoundryHW/zwo_camera/ASI_linux_mac_SDK_V1.22/lib/mac/libASICamera2.dylib.1.22\nYou must also have libusb installed (homebrew works): brew install libusb\n","categories":"","description":"ASI ZWO Astronomy Camera ScopeFoundry Hardware Component","excerpt":"ASI ZWO Astronomy Camera ScopeFoundry Hardware Component","ref":"/docs/reference/hw-components/hw_zwo_camera/","tags":"","title":"HW_zwo_camera"},{"body":"\nA Python platform for controlling custom laboratory experiments and visualizing scientific data\nQuick Install Using Anaconda with Python 3.11:\nconda install numpy pyqt qtpy h5py pyqtgraph pip install ScopeFoundry Visit Getting Started for full instructions.\nData Browser For a pre-compiled version of FoundryDataBrowser, check the releases page\nWhy ScopeFoundry? An open-source alternative to LabView or MATLAB instrument control.\nModular, cross-platform Python graphical interface allows for fast data acquisition and visualization Build lab equipment graphical interfaces interactively with Qt Creator Live updates of measurement code for fast development and debugging Hardware plug-ins for simple and complex scientific equipment Uses:\nCurrently used in multi-modal scanning microscopy measurements with electrons and optics Flexible for many other data acquisition tasks Demo Videos Demo Videos\nTutorials Learn to write your own custom components for ScopeFoundry:\nYour First Microscope Custom Measurements Hardware Plug-in Data Browser Viewer Documentation Browse documentation for currently supported hardware devices as well as advanced development topics.\nKey Concepts Advanced Development API Documentation Where to Find More For questions about using ScopeFoundry, please visit and post on the ScopeFoundry project mailing list / forum\nFor Source Code of ScopeFoundry visit our GitHub page\n","categories":"","description":"","excerpt":"\nA Python platform for controlling custom laboratory experiments and …","ref":"/_index2/","tags":"","title":"ScopeFoundry"}]